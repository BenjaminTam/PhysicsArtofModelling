\chapter{The Python programming language}
\label{app:python}
This appendix gives a very brief introduction to programming in python. 
 \vspace{1cm}
\begin{learningObjectives}
\item Be able to perform simple algebra using python
\item Be able to plot a function in python
\item Be able to propagate uncertainties in python
\item Be able to write a simple loop to numerically evaluate an integral
\end{learningObjectives}

In this textbook, we will encourage you to use computers to facilitate making calculations and displaying data. We will make use of a popular programming language called Python, as well as several ``modules'' from Python that facilitate working with numbers and data. Do not worry if you do not have any programming experience; we assume that you have none and hope that by the end of this book, you will have some capability to decrease your workload by using computers.

\section{A quick intro to programming}
In Python, as in other programming language, the equal sign is called the \textbf{assignment operator}. Its role is to \textit{assign} the value on its right to the variable on its left. The following code does the following:
\begin{itemize}
\item \textit{assigns} the value of \code{2} to the variable \code{a}
\item \textit{assigns} the values of \code{2*a} to the variable \code{b}
\item prints out the value of the variable \code{b}
\end{itemize}

\begin{python}[caption=Declaring variables in Python] 
#This is a comment, and is ignored by Python
a = 2 
b = 2*a
print(b)
\end{python}
\begin{poutput}
4
\end{poutput}
Note that any text that follows a pound sign (\#) is intended as a comment and will be ignored by Python. Inserting comments in your code is very important for being able to understand your computer program in the future or if you are sharing your code with someone who would like to understand it.


In Python, if you want to have access to ``functions'', which are more complex series of operations, then you typically need to load the \textit{module} that defines those operations. For example, if you want to be able to take the square root of a number, then you need to load (import) the ``math module'', as in the following example:
\begin{python}[caption=Using functions from modules] 
#First, we load (import) the math module
import math as m
a = 9
b = m.sqrt(a)
print(b)
\end{python}
\begin{poutput}
3
\end{poutput}
In the above code, we loaded the math module (and renamed it \code{m}); this then allows us to use the functions that are part of that module, including the square root function (\code{m.sqrt()}).

\section{The QExpy python package for experimental physics}
QExpy is a Python module that was developed with students from Queen's University to handle all aspects of undergraduate physics laboratories. In this section, we look at how to use QExpy to propagate uncertainties and to plot experimental data.

\subsection{Using QExpy for propagating uncertainties}
Recall Example \ref{ex:Chap2:derivprop}, where we propagated the uncertainties in $t$ and $x$ to $k=\frac{t}{\sqrt x}$. We show below how easily this can be done with QExpy:

\begin{python}[caption=QExpy to propagate uncertainties] 
#First, we load the QExpy module
import qexpy as q
#Now define our measurements with uncertainties:
t = q.Measurement(0.76, 0.15) #0.76 +/- 0.15
x = q.Measurement(3,0.1) #3 +/- 0.1
#Now define k, which depends on t and x:
k = t/q.sqrt(x)
#Print the result:
print(k)
\end{python}
\begin{poutput}
0.44 +/- 0.09
\end{poutput}
which is the result that we obtained when manually applying the derivative method. Note that we used the square root function from the QExpy module, as it ``knows'' how to take the square root of a value with uncertainty (a ``Measurement'' in the language of QExpy). 

Also recall that in Table \ref{tab:chap2:kmes_3m}, we have 5 different measurements of time that we used to calculate the mean and standard deviation of $t$ to use as central value and uncertainty. We can do this very easily in QExpy, by setting our value of $t$ to be equal to a list of measurements:
\begin{python}[caption=QExpy to calculate mean and standard deviation] 
#First, we load the QExpy module
import qexpy as q
#We define $t$ as a list of values (note the square brackets):
t = q.Measurement([1.01,  0.76,  0.64,  0.73,  0.66])
#Choose the number of significant figures to print:
q.set_sigfigs(2)
#Print the result:
print("t = ",t)
\end{python}
\begin{poutput}
t = 0.76 +/- 0.15
\end{poutput}
thus, we do not need to tediously calculate the mean and standard deviation, as we did in Example \ref{ex:chap2:stdcalc}.


\subsection{Using QExpy for plotting experimental data}
Recall Table \ref{tab:chap2:kmes}, where we measured the time for an object to drop from different heights. One of the easiest ways to look at the data is to visualize them on a graph. In this case, we measured the time, $t$, that it took to drop different heights, $x$. Chlo\"e's Theory stated that the time, $t$, is proportional to the square root of the distance fallen, $x$, and we introduced a constant of proportionality $k$:
\begin{align*}
t = k \sqrt{x}
\end{align*}

This means that if we make a graph of $t$ versus $\sqrt{x}$, we should expect that the points fall on a straight line that goes through zero, with a slope of $k$. We can easily use QExpy to make this plot of the data in Table \ref{tab:chap2:kmes}.
\begin{python}[caption=Using QExPy for plotting]
#First, we load the QExpy module:
import qexpy as q

#Then we enter the data:
#start with the values for the square root of height:
sqx = [1. , 1.41, 1.73, 2., 2.24]
#and then, the corresponding times:
t = [ 0.33,  0.74,  0.67,  1.07,  1.1 ]

#Let us attribute an uncertainty of 0.15 to each measured values of t:
terr = 0.15

#We now make the plot. First, we create the plot object with the data.
fig = q.MakePlot( xdata = sqx, xname = "sqrt(distance)", xunits = "sqrt(m)",
                  ydata = t, yerr = terr, yname = "time", yunits ="s",
                  data_name = "Data1")
                  
#Ask QExpy to also show the line of best fit                  
fig.fit("linear")
                  
#Then, we show it:
fig.show()         
\end{python}
\begin{poutput}
-----------------Fit results-------------------
Fit of  Data1  to  linear
Fit parameters:
Data1_linear_fit0_fitpars_intercept = -0.24 +/- 0.22,
Data1_linear_fit0_fitpars_slope = 0.61 +/- 0.13

Correlation matrix: 
[[ 1.    -0.968]
 [-0.968  1.   ]]

chi2/ndof = 2.04/2
---------------End fit results----------------
(* \capfig{0.75\textwidth}{figures/Chapter2/tvssqx.png}{\label{fig:chap2:tvssqx} QExpy plot of $t$ versus $\sqrt{x}$.} *)
\end{poutput}
The plot in Figure \ref{fig:chap2:tvssqx} shows that the data points do indeed appear to fall near a straight line. We've also asked QExpy to show us the line of best fit to the data, represented by the line with the shaded area. When we asked for the line of best fit, QExpy not only drew the line, but also gave us the values for the slope and the intercept of the line. The shaded area around the line corresponds to other possible lines that one would obtain using different values of the slope and offset within their uncertainties. The output also provides a line that tells us that \code{chi2/ndof = 2.04/2}; although you do not need to understand the details, this is a measure of how well the data are described by the line of best fit. Generally, the fit is assumed to be ``good'' if this ratio is close to 1 (the ratio is called ``the reduced chi-squared'').  The ``correlation matrix'' tells us how the best fit value of the slope is linked to the best fit value of the intercept, which you do not need to worry about here.


Since we expect the slope of the data to be $k$, this provides us a method to determine $k$ from the data as \SI{0.61\pm 0.13}{s.m^{-\frac{1}{2}}}. When we used Table \ref{tab:chap2:kmes_3m} to determine $k$ using repeated measurements at a drop height of 3.0\,m, we obtained $k=\SI{0.44\pm 0.09}{s.m^{-\frac{1}{2}}}$, which is consistent with what we get from the slope of the best fit line. Finally, we expect the intercept to be equal to zero. The best fit line from QExpy has an intercept of \SI{-0.24\pm 0.22}{s}, which is slightly below, but consistent, with zero. From these data, we would conclude that our measurements are consistent with Chlo\"e's Theory. Again, remember that we can never confirm a theory, we can only exclude it; in this case, we cannot exclude Chlo\"e's Theory.